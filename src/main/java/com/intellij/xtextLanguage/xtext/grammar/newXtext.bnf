{
    tokens = [
      ID ="regexp:\^?([a-z]|[A-Z]|_)([a-z]|[A-Z]|_|[0-9])*"
      INT ="regexp:([0-9])+"
      STRING ="regexp:\"(\\.|[^\\\"])*\"|'(\\.|[^\\'])*'"
      ML_COMMENT ="regexp:/\*(?s).*\*/"
      SL_COMMENT ="regexp://[^\n\r](\r?\n)?"
      WS ="regexp:( |\t|\r|\n)+"
      ANY_OTHER ="regexp:."
      GRAMMAR = 'grammar'
      WITH = 'with'
      COMMA = ','
      HIDDEN = 'hidden'
      L_BRACKET = '('
      R_BRACKET = ')'
      DOT = '.'
      GENERATE = 'generate'
      AS = 'as'
      IMPORT = 'import'
      AT_SIGN = '@'
      FRAGMENT = 'fragment'
      ASTERISK = '*'
      RETURNS = 'returns'
      COLON = ':'
      SEMICOLON = ';'
      L_ANGLE_BRACKET = '<'
      R_ANGLE_BRACKET = '>'
      COLONS = '::'
      PIPE = '|'
      AMPERSAND = '&'
      QUES_MARK = '?'
      PLUS = '+'
      L_BRACE = '{'
      EQUALS = '='
      PLUS_EQUALS = '+='
      CURRENT = 'current'
      R_BRACE = '}'
      TRUE = 'true'
      FALSE = 'false'
      ACX_MARK = '!'
      PRED = '=>'
      WEAK_PRED = '->'
      QUES_EQUALS = '?='
      L_SQUARE_BRACKET = '['
      R_SQUARE_BRACKET = ']'
      TERMINAL = 'terminal'
      EOF_KEY = 'EOF'
      RANGE = '..'
      ENUM = 'enum'
    ]
    parserClass="com.intellij.xtextLanguage.xtext.parser.XtextParser"
        
    extends="com.intellij.xtextLanguage.xtext.psi.impl.XtextPsiCompositeElementImpl"
    psiClassPrefix="Xtext"
    psiImplClassSuffix="Impl"
    psiPackage="com.intellij.xtextLanguage.xtext.psi"
    psiImplPackage="com.intellij.xtextLanguage.xtext.impl"

    elementTypeHolderClass="com.intellij.xtextLanguage.xtext.psi.XtextTypes"
    elementTypeClass="com.intellij.xtextLanguage.xtext.psi.XtextElementType"
    tokenTypeClass="com.intellij.xtextLanguage.xtext.psi.XtextTokenType"
    psiImplUtilClass="com.intellij.xtextLanguage.xtext.psi.impl.XtextPsiImplUtil"
    parserUtilClass= "com.intellij.languageUtil.parserUtilBase.GeneratedParserUtilBaseCopy"
    generateTokenAccessors=true
    generateTokens=true
    extraRoot(".*")= true

}
Grammar ::= 'grammar' GrammarID ('with' REFERENCE_Grammar_GrammarID (',' REFERENCE_Grammar_GrammarID  )*  )? ('hidden' '(' (REFERENCE_AbstractRule_RuleID (',' REFERENCE_AbstractRule_RuleID  )*  )? ')'  )? AbstractMetamodelDeclaration * (AbstractRule  )+  
GrammarID ::= ValidID ('.' ValidID  )*  
AbstractRule ::= ParserRule |  TerminalRule |  EnumRule  
AbstractMetamodelDeclaration ::= GeneratedMetamodel |  ReferencedMetamodel  
GeneratedMetamodel ::= 'generate' ValidID REFERENCE_ecore-EPackage_STRING ('as' ValidID  )?  
ReferencedMetamodel ::= 'import' REFERENCE_ecore-EPackage_STRING ('as' ValidID  )?  
Annotation ::= '@' ID  
ParserRule ::= (Annotation  )* ('fragment' RuleNameAndParams ('*' |  ('returns' TypeRef  )?  )|  RuleNameAndParams ('returns' TypeRef  )?  )('hidden' '(' (REFERENCE_AbstractRule_RuleID (',' REFERENCE_AbstractRule_RuleID  )*  )? ')'  )? ':' Alternatives ';'  
RuleNameAndParams ::= ValidID ('<' (Parameter (',' Parameter  )*  )? '>'  )?  
Parameter ::= ID  
TypeRef ::= (REFERENCE_AbstractMetamodelDeclaration '::'  )? REFERENCE_ecore-EClassifier  
Alternatives ::= ConditionalBranch (('|' ConditionalBranch  )+  )?  
RuleFromConditionalBranch_Group ::= '<' Disjunction '>' (AbstractToken  )+  
ConditionalBranch ::= UnorderedGroup |  RuleFromConditionalBranch_Group  
UnorderedGroup ::= Group (('&' Group  )+  )?  
Group ::= AbstractToken ((AbstractToken  )+  )?  
AbstractToken ::= AbstractTokenWithCardinality |  Action  
AbstractTokenWithCardinality ::= (Assignment |  AbstractTerminal  )('?' |  '*' |  '+'  ) ?  
Action ::= '{' TypeRef ('.' ValidID ('=' |  '+='  ) 'current'  )? '}'  
AbstractTerminal ::= Keyword |  RuleCall |  ParenthesizedElement |  PredicatedKeyword |  PredicatedRuleCall |  PredicatedGroup  
Keyword ::= STRING  
RuleCall ::= REFERENCE_AbstractRule_RuleID ('<' NamedArgument (',' NamedArgument  )* '>'  )?  
NamedArgument ::= (REFERENCE_Parameter_ID '='  )? (Disjunction  ) 
RuleFromLiteralCondition_LiteralCondition ::= ('true' |  'false'  ) 
LiteralCondition ::= RuleFromLiteralCondition_LiteralCondition  
Disjunction ::= Conjunction ('|' Conjunction  )*  
Conjunction ::= Negation ('&' Negation  )*  
RuleFromNegation_Negation ::= '!' Negation  
Negation ::= Atom |  RuleFromNegation_Negation  
Atom ::= ParameterReference |  ParenthesizedCondition |  LiteralCondition  
ParenthesizedCondition ::= '(' Disjunction ')'  
ParameterReference ::= REFERENCE_Parameter_ID  
TerminalRuleCall ::= REFERENCE_AbstractRule_RuleID  
RuleID ::= ValidID ('::' ValidID  )*  
ValidID ::= ID |  'true' |  'false'  
PredicatedKeyword ::= ('=>' |  '->'  )STRING  
PredicatedRuleCall ::= ('=>' |  '->'  )REFERENCE_AbstractRule_RuleID ('<' NamedArgument (',' NamedArgument  )* '>'  )?  
Assignment ::= ('=>' |  '->'  )? ValidID ('+=' |  '=' |  '?='  ) AssignableTerminal  
AssignableTerminal ::= Keyword |  RuleCall |  ParenthesizedAssignableElement |  CrossReference  
ParenthesizedAssignableElement ::= '(' AssignableAlternatives ')'  
AssignableAlternatives ::= AssignableTerminal (('|' AssignableTerminal  )+  )?  
CrossReference ::= '[' TypeRef ('|' CrossReferenceableTerminal  )? ']'  
CrossReferenceableTerminal ::= Keyword |  RuleCall  
ParenthesizedElement ::= '(' Alternatives ')'  
PredicatedGroup ::= ('=>' |  '->'  )'(' Alternatives ')'  
TerminalRule ::= (Annotation  )* 'terminal' ('fragment' ValidID |  ValidID ('returns' TypeRef  )?  )':' TerminalAlternatives ';'  
TerminalAlternatives ::= TerminalGroup (('|' TerminalGroup  )+  )?  
TerminalGroup ::= TerminalToken ((TerminalToken  )+  )?  
TerminalToken ::= TerminalTokenElement ('?' |  '*' |  '+'  ) ?  
TerminalTokenElement ::= CharacterRange |  TerminalRuleCall |  ParenthesizedTerminalElement |  AbstractNegatedToken |  Wildcard |  caretEOF  
ParenthesizedTerminalElement ::= '(' TerminalAlternatives ')'  
AbstractNegatedToken ::= NegatedToken |  UntilToken  
NegatedToken ::= '!' TerminalTokenElement  
UntilToken ::= '->' TerminalTokenElement  
RuleFromWildcard_Wildcard ::= '.'  
Wildcard ::= RuleFromWildcard_Wildcard  
RuleFromcaretEOF_caretEOF ::= 'EOF'  
caretEOF ::= RuleFromcaretEOF_caretEOF  
CharacterRange ::= Keyword ('..' Keyword  )?  
EnumRule ::= (Annotation  )* 'enum' ValidID ('returns' TypeRef  )? ':' EnumLiterals ';'  
EnumLiterals ::= EnumLiteralDeclaration (('|' EnumLiteralDeclaration  )+  )?  
EnumLiteralDeclaration ::= REFERENCE_ecore-EEnumLiteral ('=' Keyword  )?  
REFERENCE_Grammar_GrammarID ::= GrammarID
REFERENCE_AbstractRule_RuleID ::= RuleID
REFERENCE_ecore-EPackage_STRING ::= STRING
REFERENCE_AbstractMetamodelDeclaration ::= ID
REFERENCE_ecore-EClassifier ::= ID
REFERENCE_Parameter_ID ::= ID
REFERENCE_ecore-EEnumLiteral ::= ID
